/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.3",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        "test:coverage": "tap --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options == null ? void 0 : options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPathsThatExist = [];
      if (options == null ? void 0 : options.path) {
        if (!Array.isArray(options.path)) {
          if (fs.existsSync(options.path)) {
            optionPathsThatExist = [_resolveHome(options.path)];
          }
        } else {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              optionPathsThatExist.push(_resolveHome(filepath));
            }
          }
        }
        if (!optionPathsThatExist.length) {
          optionPathsThatExist = [dotenvPath];
        }
      }
      const pathsToProcess = optionPathsThatExist.length ? optionPathsThatExist : [dotenvPath];
      const parsed = {};
      try {
        for (const path2 of pathsToProcess) {
          const singleFileParsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
          DotenvModule.populate(parsed, singleFileParsed, options);
        }
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${pathsToProcess} ${e.message}`);
        }
        return { error: e };
      }
      return { parsed };
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RepeatLastCommands
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/cmd-utils.ts
function getConditions(plugin) {
  const { modal } = getModalCmdVars(plugin);
  const chooser = modal.chooser;
  const values = chooser.values;
  const { aliases } = plugin.settings;
  return { values, aliases, chooser };
}
function getModalCmdVars(plugin) {
  const cmdPalette = getCmdPalette(plugin);
  const instance = cmdPalette.instance;
  const modal = instance.modal;
  return { modal, instance, cmdPalette };
}
function getCmdPalette(plugin) {
  return plugin.app.internalPlugins.getPluginById("command-palette");
}
function aliasify(values, aliases) {
  values.map(async (value) => {
    if (value.item.id in aliases) {
      value.item.name = aliases[value.item.id].name;
    }
  });
}
function getBackSelection(chooser, selectedItem) {
  for (let i = 1; i <= selectedItem; i++) {
    try {
      if (selectedItem)
        chooser.moveDown(1);
    } catch (err) {
      const dd = "I don't care this error, job is done";
    }
  }
}
function getCommandName(id) {
  const command = this.app.commands.findCommand(id);
  command.name.startsWith("*") ? command.name = command.name.substring(1) : null;
  return command.name;
}
function getCommandIds(names) {
  const ids = [];
  for (const key in this.app.commands.commands) {
    const command = this.app.commands.commands[key];
    if (names.includes(command.name)) {
      ids.push(command.id);
    }
  }
  return ids;
}

// src/modals.ts
var import_obsidian = require("obsidian");
var LastCommandsModal = class extends import_obsidian.SuggestModal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  getSuggestions(query) {
    let lastCommandsArr = this.plugin.lastCommands.map((id) => [id, getCommandName(id)]).reverse();
    if (this.plugin.settings.includeCmdPaletteOPen) {
      lastCommandsArr = [...lastCommandsArr, ["command-palette:open", "Open Command Palette"]];
    }
    return lastCommandsArr.filter(
      (cmd) => cmd[1].toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(cmd, el) {
    if (cmd[1].includes(":")) {
      const [name, command] = cmd[1].toString().split(":");
      el.createEl("div", {
        cls: "cmd-suggest"
      }, (cont) => {
        cont.createEl("span", { text: `${name}:`, cls: "cmd-suggest-name" });
        cont.createEl("span", { text: `${command}`, cls: "cmd-suggest-cmd" });
      });
    } else {
      el.createEl("div", { text: `${cmd[1]}`, cls: "cmd-alone" });
    }
    if (this.plugin.settings.showCmdId)
      el.createEl("div", { text: `${cmd[0]}`, cls: "id-suggest" });
  }
  onChooseSuggestion(cmd, evt) {
    this.plugin.app.commands.executeCommandById(`${cmd[0]}`);
  }
};
var AliasModal = class extends import_obsidian.Modal {
  constructor(app, plugin, selectedItem, onSubmit, width) {
    super(app);
    this.plugin = plugin;
    this.selectedItem = selectedItem;
    this.onSubmit = onSubmit;
    this.width = width;
    this.scope = new import_obsidian.Scope(this.scope);
    this.scope.register([], "Enter", (evt, ctx) => {
      this.close();
      this.onSubmit(this.result);
    });
    if (this.width) {
      this.modalEl.style.width = `${this.width}px`;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const { chooser } = getConditions(this.plugin);
    let name = chooser.values[this.selectedItem].item.name;
    name = name.startsWith("*") ? name.substring(1) : name;
    this.titleEl.setText(`Define an alias`);
    contentEl.setText(`for: "${name}"`);
    const input = new import_obsidian.TextComponent(contentEl).setPlaceholder("enter nothing to delete previous alias").onChange(async (value) => {
      this.result = value;
    });
    const eL = input.inputEl;
    eL.addClass("alias-input");
    eL.size = 35;
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ShowAgainCmds = class extends import_obsidian.Modal {
  constructor(app, plugin, modal, width) {
    super(app);
    this.plugin = plugin;
    this.modal = modal;
    this.width = width;
    if (this.width) {
      this.modalEl.style.width = `${this.width}px`;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const excluded = this.plugin.settings.excludeCommands;
    let cmdNames = [];
    for (const id of excluded) {
      cmdNames.push(getCommandName(id));
    }
    new import_obsidian.Setting(contentEl).setName("Excluded commands from command palette").addTextArea((text) => {
      text.setValue(cmdNames.join("\n"));
      text.inputEl.onblur = async () => {
        const textArray = text.getValue() ? text.getValue().trim().split("\n") : [];
        const ids = getCommandIds(textArray);
        this.plugin.settings.excludeCommands = ids;
        await this.plugin.saveSettings();
        this.close();
        this.modal.close();
        this.app.commands.executeCommandById("command-palette:open");
      };
      text.inputEl.setAttr("rows", 4);
      text.inputEl.setAttr("cols", 40);
    });
  }
};

// src/events.ts
async function addAlias(plugin, result, selectedItem) {
  var _a;
  const { values, aliases, chooser } = getConditions(plugin);
  const { item } = values[selectedItem];
  const selectedId = item.id;
  const value = (_a = result == null ? void 0 : result.trim()) != null ? _a : "";
  const { commands } = this.app.commands;
  const commandName = commands[selectedId].name;
  let text;
  const existingAlias = commandName.match(/{(.*)}/);
  if (existingAlias) {
    const existingValue = existingAlias[1];
    if (value === "") {
      text = `${commandName.replace(`{${existingValue}}`, "")}`.trim();
      delete aliases[selectedId];
    } else {
      text = `${commandName.replace(`{${existingValue}}`, `{${value}}`)}`.trim();
      if (!plugin.wasStared)
        text = text.substring(1);
      aliases[selectedId] = { name: text };
    }
  } else {
    const parts = commandName.split(": ");
    if (parts.length > 1) {
      text = `${parts[0]}: {${value}} ${parts[1]}`.trim();
      if (!plugin.wasStared)
        text = text.substring(1);
      aliases[selectedId] = { name: text };
    } else {
      const prefix = value ? `{${value}}` : "";
      text = `${commandName} ${prefix}`.trim();
      if (!plugin.wasStared)
        text = text.substring(1);
      value ? aliases[selectedId] = { name: text } : delete aliases[selectedId];
    }
  }
  chooser.values[selectedItem].item.name = text;
  const { modal, instance, cmdPalette } = getModalCmdVars(plugin);
  if (!plugin.wasStared) {
    plugin.lastCommands.remove(selectedId);
    plugin.lastCommand = null;
  }
  plugin.wasStared = false;
  await plugin.saveSettings();
  await modal.updateSuggestions();
}
function altEvent(e, plugin, selectedItem, chooser) {
  const name = chooser.values[selectedItem].item.name;
  if (name.startsWith("*"))
    plugin.wasStared = true;
  new AliasModal(plugin.app, plugin, selectedItem, async (result) => {
    await addAlias(plugin, result, selectedItem);
    setTimeout(() => {
      getBackSelection(chooser, selectedItem);
    }, 600);
  }).open();
}
async function hideCmd(e, plugin, selectedItem, chooser) {
  const id = chooser.values[selectedItem].item.id;
  plugin.settings.excludeCommands.push(id);
  await plugin.saveSettings();
}

// src/palette.ts
function addCPListeners(plugin) {
  addInfoPalette(plugin);
  addClickListener(plugin);
  setTimeout(() => {
    addKeyboardListener(plugin);
  }, 800);
}
function onHKTrigger(plugin, id) {
  const { modal } = getModalCmdVars2(plugin);
  if (!modal.win && !getRejectedCondition(plugin, id)) {
    applySelectedId(id, plugin);
  }
}
function onCommandTrigger(plugin) {
  const uninstallCommand = around(this.app.commands, {
    executeCommand(originalMethod) {
      return function(...args) {
        if (args[0].id === "command-palette:open")
          addCPListeners(plugin);
        else
          onHKTrigger(plugin, args[0].id);
        const result = originalMethod && originalMethod.apply(this, args);
        return result;
      };
    }
  });
  return uninstallCommand;
}
function getRejectedCondition(plugin, id) {
  const userExcludedIDs = plugin.settings.userExcludedIDs;
  return id === "repeat-last-commands:repeat-command" || id === "repeat-last-commands:repeat-commands" || id === "repeat-last-commands:get-last-command" || userExcludedIDs.some((excludedID) => id.startsWith(excludedID));
}
function applySelectedId(id, plugin) {
  const { lastCommands, settings } = plugin;
  plugin.lastCommand = id;
  const maxEntries = settings.maxLastCmds;
  if (lastCommands.length > maxEntries) {
    lastCommands.shift();
  }
  lastCommands.push(id);
  plugin.lastCommands = [...new Set(lastCommands)];
  plugin.saveSettings();
}
async function registerCPCmd(e, plugin) {
  var _a, _b;
  if (e instanceof KeyboardEvent && (e.key === "ArrowDown" || e.key === "ArrowUp"))
    return;
  const { modal, instance, pluginCommand } = getModalCmdVars2(plugin);
  const { values, aliases, chooser } = getConditions(plugin);
  if (!values)
    return;
  const { settings } = plugin;
  const selectedItem = chooser.selectedItem;
  const selectedId = (_a = values[selectedItem]) == null ? void 0 : _a.item.id;
  const selectedName = (_b = values[selectedItem]) == null ? void 0 : _b.item.name;
  if (Object.keys(aliases).length || settings.sort) {
    setTimeout(async () => {
      if (Object.keys(aliases).length) {
        aliasify(values, aliases);
      }
      if (settings.sort && plugin.lastCommands.length && values) {
        for (const value of values) {
          if (plugin.lastCommands.includes(value.item.id)) {
            if (!value.item.name.startsWith("*")) {
              value.item.name = "*" + value.item.name;
            }
          } else {
            if (value.item.name.startsWith("*")) {
              value.item.name = value.item.name.substring(1);
            }
          }
        }
      }
      await modal.updateSuggestions();
      instance.saveSettings(pluginCommand);
    }, 400);
  }
  if (e instanceof KeyboardEvent) {
    if (e.ctrlKey && e.key === "-") {
      await hideCmd(e, plugin, selectedItem, chooser);
      modal.close();
      this.app.commands.executeCommandById("command-palette:open");
      return;
    } else if (e.ctrlKey && e.key === "+") {
      new ShowAgainCmds(this.app, plugin, modal).open();
      return;
    } else if (e.ctrlKey && e.key === "h") {
      modal.close();
      showHotkeysFor(e, selectedName);
      return;
    } else if (e.key === "Alt") {
      altEvent(e, plugin, selectedItem, chooser);
      return;
    } else if (e.key === "Tab") {
      const pinned = instance.options.pinned;
      if (pinned.includes(selectedId)) {
        pinned.remove(selectedId);
      } else {
        instance.options.pinned.push(selectedId);
      }
      instance.saveSettings(pluginCommand);
      setTimeout(() => {
        getBackSelection(chooser, selectedItem);
      }, 400);
      return;
    } else if (e.key === "Enter") {
      const rejectedIds = getRejectedCondition(plugin, selectedId);
      if (rejectedIds)
        return;
      applySelectedId(selectedId, plugin);
    } else {
      return;
    }
  } else {
    const rejectedIds = getRejectedCondition(plugin, selectedId);
    if (rejectedIds)
      return;
    applySelectedId(selectedId, plugin);
  }
}
function addClickListener(plugin) {
  const { modal } = getModalCmdVars2(plugin);
  const resultContainerEl = modal.resultContainerEl;
  resultContainerEl.addEventListener("click", async (e) => await registerCPCmd(e, plugin));
}
function addKeyboardListener(plugin) {
  const { modal } = getModalCmdVars2(plugin);
  const keyupEventListener = (e) => registerCPCmd(e, plugin);
  document.addEventListener("keyup", keyupEventListener);
  const closeModal = plugin.app.internalPlugins.getPluginById("command-palette").instance.modal.onClose;
  plugin.app.internalPlugins.getPluginById("command-palette").instance.modal.onClose = () => {
    setTimeout(() => {
      document.removeEventListener("keyup", keyupEventListener);
    }, 400);
    closeModal.apply(modal);
  };
}
function getModalCmdVars2(plugin) {
  const pluginCommand = plugin.app.internalPlugins.getPluginById("command-palette");
  const instance = pluginCommand.instance;
  const modal = instance.modal;
  return { modal, instance, pluginCommand };
}
function addInfoPalette(plugin) {
  const { modal } = getModalCmdVars2(plugin);
  const resultContainerEl = modal.resultContainerEl;
  if (!plugin.infoDiv) {
    plugin.infoDiv = document.createElement("div");
    plugin.infoDiv.classList.add("result-container-afterend");
    plugin.infoDiv.textContent = "Alt: alias | Tab: pin | Ctrl -: hide | Ctrl +: show | Ctrl h: hotkey";
    resultContainerEl.insertAdjacentElement("afterend", plugin.infoDiv);
  }
}
var showHotkeysFor = async function(evt, selectedName) {
  evt.preventDefault();
  await this.app.setting.open();
  await this.app.setting.openTabById("hotkeys");
  const tab = await this.app.setting.activeTab;
  tab.searchComponent.inputEl.value = selectedName;
  tab.updateHotkeyVisibility();
  tab.searchComponent.inputEl.blur();
  const old = this.app.setting.onClose;
  this.app.setting.onClose = () => {
    this.app.commands.executeCommandById("command-palette:open");
    this.app.setting.onClose = old;
  };
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var RLCSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  display() {
    const { containerEl: El } = this;
    El.empty();
    El.createEl("h3", { text: "Repeat last command" });
    new import_obsidian2.Setting(El).setName("notify last command").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.notify).onChange(async (value) => {
        this.plugin.settings.notify = value;
        await this.plugin.saveSettings();
      });
    });
    El.createEl("h3", { text: "Repeat last commands" });
    new import_obsidian2.Setting(El).setName("Number max of commands to show").addSlider((slider) => {
      slider.setLimits(2, 12, 1).setValue(this.plugin.settings.maxLastCmds).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxLastCmds = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(El).setName("If no last command(s), then open command palette instead").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ifNoCmdOpenCmdPalette).onChange(async (value) => {
        this.plugin.settings.ifNoCmdOpenCmdPalette = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(El).setName("Show command id (2nd line)").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showCmdId).onChange(async (value) => {
        this.plugin.settings.showCmdId = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(El).setName('Add "open command palette" as last command').addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.includeCmdPaletteOPen).onChange(async (value) => {
        this.plugin.settings.includeCmdPaletteOPen = value;
        await this.plugin.saveSettings();
      });
    });
    const fragment = new DocumentFragment();
    fragment.createDiv({}, (div) => {
      div.innerHTML = `ex: 'repeat-last-commands:repeat-command'<br> 
        or 'repeat-last-commands' \u2192 all commands from this plugin.<br>
        Use 'Copy last command id in clipbooard', in command palette, to get last command id`;
    });
    new import_obsidian2.Setting(El).setName("Add last command(s) exeptions IDs (separated by new line)").setDesc(fragment).addTextArea((text) => {
      text.setValue(this.plugin.settings.userExcludedIDs.join("\n")).onChange(async (value) => {
        this.plugin.settings.userExcludedIDs = value.split("\n");
        await this.plugin.saveSettings();
      });
    });
    El.createEl("h3", { text: "Command palette" });
    new import_obsidian2.Setting(El).setName("Recently used commands at top of command palette").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.sort).onChange(async (value) => {
        this.plugin.settings.sort = value;
        await this.plugin.saveSettings();
      });
    });
    const excluded = this.plugin.settings.excludeCommands;
    let cmdNames = [];
    for (const id of excluded) {
      cmdNames.push(getCommandName(id));
    }
    new import_obsidian2.Setting(El).setName("Excluded commands from command palette").addTextArea((text) => {
      text.setValue(cmdNames.join("\n"));
      text.inputEl.onblur = async () => {
        const textArray = text.getValue() ? text.getValue().trim().split("\n") : [];
        const ids = getCommandIds(textArray);
        this.plugin.settings.excludeCommands = ids;
        await this.plugin.saveSettings();
      };
      text.inputEl.setAttr("rows", 4);
      text.inputEl.setAttr("cols", 40);
    });
  }
};

// src/variables.ts
var DEFAULT_SETTINGS = {
  maxLastCmds: 4,
  notify: true,
  aliases: {},
  sort: true,
  userExcludedIDs: [],
  ifNoCmdOpenCmdPalette: true,
  includeCmdPaletteOPen: false,
  showCmdId: false,
  excludeCommands: []
};

// src/Console.ts
var import_obsidian3 = require("obsidian");
var DEBUG = "false";
if (import_obsidian3.Platform.isDesktopApp) {
  require_main().config();
  DEBUG = "false";
}
var Console = {
  debug: (...args) => {
    if (DEBUG.trim().toLowerCase() === "true") {
      console.debug(...args);
    }
  },
  log: (...args) => {
    if (DEBUG.trim().toLowerCase() === "true") {
      console.log(...args);
    }
  }
};

// src/main.ts
var RepeatLastCommands = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.lastCommands = [];
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new RLCSettingTab(this));
    const { settings } = this;
    this.register(around(this.app.commands.constructor.prototype, {
      listCommands(old) {
        return function(...args) {
          const commands = old.call(this, ...args);
          return commands.filter((command) => !settings.excludeCommands.includes(command.id));
        };
      }
    }));
    this.register(onCommandTrigger(this));
    const text = this.settings.ifNoCmdOpenCmdPalette ? "No last command.\nopening command palette..." : "No last command";
    this.addCommand({
      id: "repeat-command",
      name: "Repeat last command",
      callback: async () => {
        if (this.lastCommand) {
          if (this.settings.notify) {
            new import_obsidian4.Notice(`Repeated: ${getCommandName(this.lastCommand)}`);
          }
          ;
          Console.log("this.lastCommand", this.lastCommand);
          this.app.commands.executeCommandById(this.lastCommand);
        } else {
          new import_obsidian4.Notice(text, 2500);
          if (this.settings.ifNoCmdOpenCmdPalette) {
            setTimeout(() => {
              this.app.commands.executeCommandById("command-palette:open");
            }, 400);
          }
        }
      }
    });
    this.addCommand({
      id: "repeat-commands",
      name: "Repeat commands",
      callback: async () => {
        if (this.lastCommands.length) {
          new LastCommandsModal(this).open();
        } else {
          new import_obsidian4.Notice(text, 2500);
          if (this.settings.ifNoCmdOpenCmdPalette) {
            setTimeout(() => {
              this.app.commands.executeCommandById("command-palette:open");
            }, 400);
          }
        }
      }
    });
    this.addCommand({
      id: "get-last-command",
      name: "Copy last command id in clipbooard",
      callback: async () => {
        if (this.lastCommand) {
          navigator.clipboard.writeText(this.lastCommand).then((text2) => {
            new import_obsidian4.Notice("Command id copied in clipboard");
          }).catch((err) => {
            console.error(err);
          });
        } else
          new import_obsidian4.Notice("No last command");
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
